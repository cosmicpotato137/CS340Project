# -*- coding: utf-8 -*-
"""AlgsProject

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19wZLJf6FPzf542hQa5zeEovv-FLYsoH_

#Helper functions
"""


import re
import pandas as pd
import numpy as np
import brynmawr.get_bmc_info as bmc
import haverford.get_haverford_info as hav
from sbbst import *
import time as ts


# static counter class for experimental timekeeping
class Counter:
    i = 0

    @staticmethod
    def reset():
        Counter.i = 0
        pass

    @staticmethod
    def tick(n=1):
        Counter.i += n
        pass

    @staticmethod
    def set(i):
        Counter.i = i


# Section class for holding data for each timeslot and class
class Section:
    time = None
    room = None
    cls = None  # Class
    applicants = []
    accepted = []
    professor = None
    room = None
    tmax = 0

    def __init__(self, time, cls, applicants, room=None):
        # We can and should add professor to this?
        self.time = time
        self.room = room
        self.cls = cls
        self.applicants = applicants
        self.tmax = len(applicants)

    def __repr__(self) -> str:
        return self.__str__()

    def __str__(self) -> str:
        return "Class: " + str(self.cls) + " Professor: " + str(self.professor) + \
            " Time: " + str(self.time) + " Room: " + str(self.room)\
            + " Accepted: " + str(self.accepted)


def get_section_val(sec: Section):
    return sec.tmax


# todo: priority queue
# todo: make sure students only enrolled in at most 4 classes
def make_schedule(students, classes, rooms, times, profs):
    t0 = ts.time() * 1000
    # array of sections
    schedule = []

    tree = sbbst(getVal=get_section_val)

    # total starting sections
    sections = {}
    for cls in classes.keys():
        sections[cls] = {}

        # set applicants for the class
        applicants = []
        for student_id in range(len(students)):
            for cls_pref in students["class_list"][student_id]:
                Counter.tick()  # I hope I didn't break anything
                if cls == cls_pref:  # If the student likes this class
                    applicants.append(students["name"][student_id])

            # Could we replace the last few lines with this?
            # Counter.tick(len(students["class_list"][sudent_id]))
            # if cls in students["class_list"][sudent_id]:
            #   applicants.append(students["name"][sudent_id])

        # set applicants for all times of the section
        for time in times:
            Counter.tick()
            sec = Section(time, cls, applicants[:])
            sections[cls][time] = sec
            tree.insert(sec)

    # get sorted list of rooms for each section
    Counter.tick(len(rooms) * (int)(np.log2(len(rooms))))
    sorted_rooms = rooms.sort_values(by="capacity", ascending=False)
    Counter.tick(len(times))
    rooms = {time: sorted_rooms.copy()
             for time in times}            # I don't understand this

    t1 = ts.time() * 1000 - t0
    # print(t1)
    # while there are valid classes left
    while (True):
        t1 = ts.time() * 1000
        # todo: naive way of doing this, must fix!!!
        # search for the class with the largest possible size
        max_size = 0
        name = ""
        max_cls = None
        max_time = 0
        for cls in sections.keys():  # Class
            for time in sections[cls].keys():  # Time
                s, n = class_size(sections[cls][time], rooms)
                if max_size < s:
                    Counter.tick()
                    max_size = s
                    name = n
                    max_cls = cls
                    max_time = time
        if max_size == 0:
            break

        # get the room info and remove the room from the current section
        idx = rooms[max_time].index[0]
        room = rooms[max_time]["room"][idx]
        rooms[max_time].drop(idx, inplace=True)
        # get section info and append to final schedule
        sec = sections[max_cls][max_time]
        sec.room = room
        sec.professor = classes[max_cls]
        sec.accepted = sec.applicants[:min(max_size, len(sec.applicants))]
        schedule.append(sec)

        # remove conflicting sections from contention
        sections.pop(max_cls)
        for cls in profs[sec.professor]:
            Counter.tick()
            try:
                sections[cls].pop(max_time)  # Love this
            except:
                #print(max_cls, cls)
                pass

        # can't schedule multiple students at the same time
        # is there a way to speed this up?
        for cls in sections.keys():
            for student in sec.accepted:
                if max_time in sections[cls].keys() and student in sections[cls][max_time].applicants:
                    sections[cls][max_time].applicants.remove(student)

        t2 = ts.time() * 1000 - t1
        # print(t2)
        # endwhile
        # for time in sections[max_cls]:
        #     Counter.tick()
        #     sections[max_cls][time].applicants = []
        # for cls in profs[sec.professor]:
        #     Counter.tick()
        #     sections[cls][max_time].applicants = []
        # for cls in sections:
        #     Counter.tick()
        #     sections[cls][max_time].applicants = []

    return schedule


# function for finding max class size of a section :D
def class_size(section: Section, rooms: dict):
    if len(rooms[section.time]) == 0:
        return (0, "")
    idx = rooms[section.time].index[0]
    size = min(len(section.applicants), rooms[section.time]["capacity"][idx])
    name = rooms[section.time]["room"][idx]
    return (size, name)


# find the accuracy of the schedule
def schedule_rating(schedule):
    total = 0
    accepted = 0
    for sec in schedule:
        total += len(sec.applicants)
        accepted += len(sec.accepted)
    return accepted / total


# make a file out of a list of Sections
def schedule_to_file(schedule, output_file):
    lines = ["Course\tRoom\tTeacher\tTime\tStudents\n"]
    for sec in schedule:
        students = ""
        for student in sec.accepted:
            students += f"{student} "
        lines.append(
            f"{sec.cls}\t{sec.room}\t{sec.professor}\t{sec.time}\t{students}\n")

    with open(output_file, "w") as file:
        file.writelines(lines)


# read format data from list of constraints and prefs
def prep_data(constraints, student_prefs):
    row = []
    with open(constraints, "r") as file:
        row = file.readlines()

    i = 0
    num_times = int(row[i].split()[-1])
    times = [str(i) for i in range(num_times)]
    i += 1
    while row[i].split()[0] != "Rooms":
        times[i-1] = re.search(r"[0-9]+", row[0])
        # times[i-1] = row[i][idx.end(0):]
        i += 1

    rooms = {"room": [], "capacity": []}

    i += 1
    while row[i].split()[0] != "Classes":
        r = row[i].split()
        rooms["room"].append(r[0])
        rooms["capacity"].append(int(r[1]))
        i += 1
    rooms = pd.DataFrame.from_dict(rooms)

    profs = {}
    classes = {}
    rows = int(row[i].split()[1]) + i + 2
    i += 2
    while i < rows:
        r = row[i].split()
        if profs.get(r[1]) != None:
            profs[r[1]] += [r[0]]
        else:
            profs[r[1]] = [r[0]]
        classes[r[0]] = r[1]
        i += 1

    rows = []
    with open(student_prefs, "r") as file:
        rows = file.readlines()

    students = {"name": [], "class_list": []}
    for row in rows[1:]:
        r = row.split()
        students["name"].append(r[0])
        students["class_list"].append(r[1:])

    students = pd.DataFrame.from_dict(students)

    return (students, classes, rooms, times, profs)
