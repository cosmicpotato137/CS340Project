# -*- coding: utf-8 -*-
"""AlgsProject

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19wZLJf6FPzf542hQa5zeEovv-FLYsoH_

# Helper functions
"""


import re
import pandas as pd
import numpy as np
import brynmawr.get_bmc_info as bmc
import haverford.get_haverford_info as hav
from sbbst import *
import time as ts


# static counter class for experimental timekeeping
class Counter:
    i = 0

    @staticmethod
    def reset():
        Counter.i = 0
        pass

    @staticmethod
    def tick(n=1):
        Counter.i += n
        pass

    @staticmethod
    def set(i):
        Counter.i = i


# Section class for holding data for each timeslot and class
class Section:
    def __init__(self, id, time, cls, cls_p):
        # We can and should add professor to this?
        self.id = id
        self.time = time
        self.room = None
        self.cls = cls
        self.applicants = [{}, {}, {}, {}]
        self.size = 0  # min num apps and room size
        self.tmax = 0  # theoretical max size (num applicants)
        self.professor = None
        self.class_p = cls_p  # class priority 0-3
        self.num_applicants = 0

    def __repr__(self) -> str:
        return self.__str__()

    def __str__(self) -> str:
        return "Class: " + str(self.cls) + " Professor: " + str(self.professor) + \
            " Time: " + str(self.time) + " Room: " + str(self.room)\
            + " Accepted: " + str(self.accepted) + " TMax: " + str(self.tmax)


def cmp_sections(x: Section, y: Section):
    if x.tmax > y.tmax:
        return True
    elif x.tmax == y.tmax:
        if x.class_p > y.class_p:
            return True
        elif x.class_p == y.class_p:
            if x.id > y.id:
                return True
            else:
                return False
        else:
            return False
    else:
        return False


# todo: priority queue
# todo: make sure students only enrolled in at most 4 classes
def make_schedule(students, classes, rooms, times, profs, student_ps=None, class_ps=None):
    t0 = ts.time() * 1000
    # array of sections
    schedule = {}

    # init sections
    sections = {}
    sections_list = []
    id = 0
    for cls in classes.keys():
        sections[cls] = {}
        # set applicants for all times of the section
        for time in times:
            Counter.tick()
            sec = Section(id, time, cls, class_ps[cls])
            sections[cls][time] = sec
            sections_list.append(sec)
            id += 1

    # set hashmap of booked times
    # booked_times = {s: [] for s in students.keys()}

    # get sorted list of rooms for each section
    # Counter.tick(len(rooms) * (int)(np.log2(len(rooms))))
    sorted_rooms = rooms.sort_values(by="capacity", ascending=False)
    # Counter.tick(len(times))

    # todo: make array of rooms and keep track of timeslot indices
    rooms = {time: sorted_rooms.copy()
             for time in times}            # I don't understand this

    # todo: make array of t bst's
    # get student interest
    for student_id in students.keys():
        for cls in students[student_id]:
            # set hashmap of student interest
            if cls not in sections.keys():
                continue
            for time in sections[cls].keys():
                sections[cls][time].applicants[student_ps[student_id]
                                               ][student_id] = False
                sections[cls][time].tmax = class_rating(
                    sections[cls][time], rooms)
                sections[cls][time].num_applicants += 1

    tree = sbbst(sections_list, fun=cmp_sections)

    # t1 = ts.time() * 1000 - t0
    # print(t1)
    # while there are valid classes left
    while (tree.head is not None):
        max_sec: Section = tree.getMaxVal()
        max_time = max_sec.time
        max_cls = max_sec.cls

        if rooms[max_time].size == 0:
            tree.delete(max_sec)
            continue

        # t1 = ts.time() * 1000

        # get the room info and remove the room from the current time
        idx = rooms[max_time].index[0]
        room = rooms[max_time]["room"][idx]
        room_size = rooms[max_time]["capacity"][idx]
        rooms[max_time].drop(idx, inplace=True)
        # get section info and append to final schedule
        sec = sections[max_cls][max_time]
        sec.room = room
        sec.professor = classes[max_cls]
        sec.size = room_size

        num_acc = 0
        for i in range(1, 5):
            for key in sec.applicants[-i].keys():
                sec.applicants[-i][key] = True
                num_acc += 1
                if num_acc >= sec.size:
                    break

        schedule[max_cls] = sec

        # remove conflicting sections from contention
        for time in sections[max_cls].keys():
            tree.delete(sections[max_cls][time])
        sections.pop(max_cls)

        # t15 = ts.time() * 1000 - t1
        # ti = ts.time() * 1000

        for cls in profs[sec.professor]:
            Counter.tick()
            if cls in sections.keys():
                tree.delete(sections[cls][max_time])
                sections[cls].pop(max_time)  # Love this

        # t2 = ts.time() * 1000 - ti
        # ti = ts.time() * 1000
        # can't schedule multiple students at the same time
        # is there a way to speed this up?
        for i in range(4):
            for student in sec.applicants[i].keys():
                if sec.applicants[i][student] == False:
                    continue
                for cls in students[student]:
                    if cls in sections.keys() and time in sections[cls].keys() and student in sections[cls][time].applicants[i].keys():
                        sections[cls][time].applicants[i].pop(student)
                        tree.delete(sections[cls][time])
                        sections[cls][time].tmax = class_rating(
                            sections[cls][time], rooms)
                        tree.insert(sections[cls][time])

    print(ts.time() * 1000 - t0)

    return schedule


def assign_students(schedule, students):
    for key in students.keys():
        times = []
        for cls in students[key]:
            if cls in schedule.keys() and not (schedule[cls].time in times) and \
                    len(schedule[cls].accepted) < schedule[cls].size:
                schedule[cls].accepted.append(key)
                times.append(schedule[cls].time)
    return schedule


# function for finding max class size of a section :D
def class_rating(section: Section, rooms):
    if rooms[section.time].empty:
        return 0
    idx = rooms[section.time].index[0]
    size = min(section.num_applicants, rooms[section.time]["capacity"][idx])
    name = rooms[section.time]["room"][idx]
    return size


# find the accuracy of the schedule
def schedule_rating(schedule, students):
    total = 0
    accepted = 0
    for key in students.keys():
        for cls in students[key]:
            if cls in schedule.keys():
                total += 1
    for key in schedule.keys():
        for i in range(4):
            for app in schedule[key].applicants[i].keys():
                accepted += schedule[key].applicants[i][app]

    return accepted / total


# make a file out of a list of Sections
def schedule_to_file(schedule, output_file):
    lines = ["Course\tRoom\tTeacher\tTime\tStudents\n"]
    for key in schedule.keys():
        students = ""
        for i in range(4):
            for student in schedule[key].applicants[i].keys():
                if schedule[key].applicants[i][student]:
                    students += f"{student} "
        lines.append(
            f"{schedule[key].cls}\t{schedule[key].room}\t{schedule[key].professor}\t{schedule[key].time}\t{students}\n")

    with open(output_file, "w") as file:
        file.writelines(lines)


# read format data from list of constraints and prefs
def prep_data(constraints, student_prefs):
    row = []
    with open(constraints, "r") as file:
        row = file.readlines()

    i = 0
    num_times = int(row[i].split()[-1])
    times = [str(i) for i in range(num_times)]
    i += 1
    while row[i].split()[0] != "Rooms":
        idx = re.search(r"[0-9]+[\s\t]+", row[i])
        times[i-1] = int(idx.group(0))
        i += 1

    rooms = {"room": [], "capacity": []}

    i += 1
    while row[i].split()[0] != "Classes":
        r = row[i].split()
        rooms["room"].append(r[0])
        rooms["capacity"].append(int(r[1]))
        i += 1
    rooms = pd.DataFrame.from_dict(rooms)

    profs = {}
    classes = {}
    rows = int(row[i].split()[1]) + i + 2
    i += 2
    while i < rows:
        r = row[i].split()
        if profs.get(r[1]) != None:
            profs[r[1]] += [r[0]]
        else:
            profs[r[1]] = [r[0]]
        classes[r[0]] = r[1]
        i += 1

    rows = []
    with open(student_prefs, "r") as file:
        rows = file.readlines()

    students = {}
    for row in rows[1:]:
        r = row.split()
        students[r[0]] = r[1:]

    return (students, classes, rooms, times, profs)


def class_priority(classes):
    p = {}
    for cls in classes.keys():
        p[cls] = np.random.randint(0, 3)
    return p


def student_priority(students):
    p = {}
    for st in students.keys():
        p[st] = np.random.randint(1, 4)
    return p
