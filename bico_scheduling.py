# -*- coding: utf-8 -*-
"""AlgsProject

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19wZLJf6FPzf542hQa5zeEovv-FLYsoH_

#Helper functions
"""


import re
import pandas as pd
import numpy as np
import brynmawr.get_bmc_info as bmc
import haverford.get_haverford_info as hav
from sbbst import *
import time as ts


# static counter class for experimental timekeeping
class Counter:
    i = 0

    @staticmethod
    def reset():
        Counter.i = 0
        pass

    @staticmethod
    def tick(n=1):
        Counter.i += n
        pass

    @staticmethod
    def set(i):
        Counter.i = i


# Section class for holding data for each timeslot and class
class Section:
    id = -1
    time = None
    room = None
    cls = None  # Class
    applicants = []
    accepted = []
    professor = None
    tmax = 0

    def __init__(self, id, time, cls, applicants, room=None):
        # We can and should add professor to this?
        self.id = id
        self.time = time
        self.room = room
        self.cls = cls
        self.applicants = applicants

    def __repr__(self) -> str:
        return self.__str__()

    def __str__(self) -> str:
        return "Class: " + str(self.cls) + " Professor: " + str(self.professor) + \
            " Time: " + str(self.time) + " Room: " + str(self.room)\
            + " Accepted: " + str(self.accepted) + " TMax: " + str(self.tmax)


def cmp_sections(x: Section, y: Section):
    if x.tmax > y.tmax:
        return True
    elif x.tmax == y.tmax:
        if x.id > y.id:
            return True
        else:
            return False
    else:
        return False


# todo: priority queue
# todo: make sure students only enrolled in at most 4 classes
def make_schedule(students, classes, rooms, times, profs):
    t0 = ts.time() * 1000
    # array of sections
    schedule = []

    # total starting sections
    sections = {}
    tree = sbbst(fun=cmp_sections)
    id = 0
    for cls in classes.keys():
        sections[cls] = {}

        # set applicants for the class
        applicants = []
        for student_id in range(len(students)):
            for cls_pref in students["class_list"][student_id]:
                Counter.tick()  # I hope I didn't break anything
                if cls == cls_pref:  # If the student likes this class
                    applicants.append(students["name"][student_id])

            # Could we replace the last few lines with this?
            # Counter.tick(len(students["class_list"][sudent_id]))
            # if cls in students["class_list"][sudent_id]:
            #   applicants.append(students["name"][sudent_id])

        # set applicants for all times of the section
        for time in times:
            Counter.tick()
            sec = Section(id, time, cls, applicants[:])
            sec.tmax = len(applicants)
            sections[cls][time] = sec
            tree.insert(sec)
            id += 1

    # get sorted list of rooms for each section
    Counter.tick(len(rooms) * (int)(np.log2(len(rooms))))
    sorted_rooms = rooms.sort_values(by="capacity", ascending=False)
    Counter.tick(len(times))
    rooms = {time: sorted_rooms.copy()
             for time in times}            # I don't understand this

    t1 = ts.time() * 1000 - t0
    print(t1)
    # while there are valid classes left
    while (tree.head is not None):
        t1 = ts.time() * 1000
        max_sec: Section = tree.getMaxVal()
        max_time = max_sec.time
        max_cls = max_sec.cls
        max_size = max_sec.tmax

        # get the room info and remove the room from the current time
        idx = rooms[max_time].index[0]
        room = rooms[max_time]["room"][idx]
        room_size = rooms[max_time]["capacity"][idx]
        rooms[max_time].drop(idx, inplace=True)
        # get section info and append to final schedule
        sec = sections[max_cls][max_time]
        sec.room = room
        sec.professor = classes[max_cls]
        sec.accepted = sec.applicants[:min(room_size, len(sec.applicants))]

        # if (schedule_dict.get((max_cls, max_time, max_sec.professor)) is None):
        # schedule_dict[(max_cls, max_time, max_sec.professor)] = max_sec
        schedule.append(sec)

        # remove conflicting sections from contention
        for time in sections[max_cls].keys():
            tree.delete(sections[max_cls][time])
        sections.pop(max_cls)

        for cls in profs[sec.professor]:
            Counter.tick()
            try:
                tree.delete(sections[cls][max_time])
                sections[cls].pop(max_time)  # Love this
            except:
                pass

        t2 = ts.time() * 1000 - t1

        # can't schedule multiple students at the same time
        # is there a way to speed this up?
        for cls in sections.keys():
            try:
                for student in sec.accepted:
                    if student in students["cl"][max_time].applicants:
                        sections[cls][max_time].applicants.remove(student)
                tree.delete(sections[cls][max_time])
                sections[cls][max_time].tmax = len(
                    sections[cls][max_time].applicants)
                tree.insert(sections[cls][max_time])
            except:
                pass

        t3 = ts.time() * 1000 - t1 - t2
        print(t2, t3)

    print(ts.time() * 1000 - t0)

    return schedule


# function for finding max class size of a section :D
def class_rating(section: Section):
    return len(section.applicants)
    # if len(rooms[section.time]) == 0:
    #     return (0, "")
    # idx = rooms[section.time].index[0]
    # size = min(len(section.applicants), rooms[section.time]["capacity"][idx])
    # name = rooms[section.time]["room"][idx]
    # return (size, name)


# find the accuracy of the schedule
def schedule_rating(schedule):
    total = 0
    accepted = 0
    for sec in schedule:
        total += len(sec.applicants)
        accepted += len(sec.accepted)
    return accepted / total


# make a file out of a list of Sections
def schedule_to_file(schedule, output_file):
    lines = ["Course\tRoom\tTeacher\tTime\tStudents\n"]
    for sec in schedule:
        students = ""
        for student in sec.accepted:
            students += f"{student} "
        lines.append(
            f"{sec.cls}\t{sec.room}\t{sec.professor}\t{sec.time}\t{students}\n")

    with open(output_file, "w") as file:
        file.writelines(lines)


# read format data from list of constraints and prefs
def prep_data(constraints, student_prefs):
    row = []
    with open(constraints, "r") as file:
        row = file.readlines()

    i = 0
    num_times = int(row[i].split()[-1])
    times = [str(i) for i in range(num_times)]
    i += 1
    while row[i].split()[0] != "Rooms":
        idx = re.search(r"[0-9]+[\s\t]+", row[i])
        times[i-1] = int(idx.group(0))
        i += 1

    rooms = {"room": [], "capacity": []}

    i += 1
    while row[i].split()[0] != "Classes":
        r = row[i].split()
        rooms["room"].append(r[0])
        rooms["capacity"].append(int(r[1]))
        i += 1
    rooms = pd.DataFrame.from_dict(rooms)

    profs = {}
    classes = {}
    rows = int(row[i].split()[1]) + i + 2
    i += 2
    while i < rows:
        r = row[i].split()
        if profs.get(r[1]) != None:
            profs[r[1]] += [r[0]]
        else:
            profs[r[1]] = [r[0]]
        classes[r[0]] = r[1]
        i += 1

    rows = []
    with open(student_prefs, "r") as file:
        rows = file.readlines()

    students = {}
    for row in rows[1:]:
        r = row.split()
        students[r[0]] = r[1:]

    students = pd.DataFrame.from_dict(students)

    return (students, classes, rooms, times, profs)
