# -*- coding: utf-8 -*-
"""AlgsProject

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19wZLJf6FPzf542hQa5zeEovv-FLYsoH_

#Helper functions
"""


import csv
import csv
import re
import pandas as pd
import numpy as np
import os
import brynmawr.get_bmc_info as prep_hav
import haverford.get_haverford_info as prep_bmc


# get haverford college data
class Hav:
    def get_data_list_of_dicts(filename):
        list = []
        with open(filename) as f:
            f_csv = csv.DictReader(f)
            for row in f_csv:
                list.append(row)
        return list

    def get_room_sizes(list_of_dicts):
        room_sizes_dict = {}
        for dict in list_of_dicts:
            room = dict["Facil ID 1"]
            status = dict["Status"]
            course = dict["Course ID"]
            campus = dict["College"]
            if status == "E" and campus == "H" and not room == "":
                if room in room_sizes_dict:
                    if course in room_sizes_dict[room]:
                        room_sizes_dict[room][course] = room_sizes_dict[room][course] + 1
                    else:
                        room_sizes_dict[room][course] = 1
                else:
                    room_sizes_dict[room] = {}
                    room_sizes_dict[room][course] = 1

        room_capacities = {}
        for room in room_sizes_dict:
            capacity = 0
            for course in room_sizes_dict[room]:
                if room_sizes_dict[room][course] > capacity:
                    capacity = room_sizes_dict[room][course]
            room_capacities[room] = capacity
        return room_capacities

    def get_student_prefs_enrolled(list_of_dicts):
        student_prefs = {}
        for dict in list_of_dicts:
            student = dict["Student"]
            course = dict["Course ID"]
            status = dict["Status"]
            if status == "E":
                if student in student_prefs:
                    student_prefs[student].append(course)
                else:
                    student_prefs[student] = [course]
        return student_prefs

    def get_courses(list_of_dicts):
        courses = {}
        for dict in list_of_dicts:
            course = dict["Course ID"]
            campus = dict["College"]
            if not course in courses and campus == "H" and dict["Instructor ID"] != "":
                courses[course] = dict["Instructor ID"]
        return courses

    def get_prof_courses(list_of_dicts):
        profs = {}
        for dict in list_of_dicts:
            prof = dict["Instructor ID"]
            course = dict["Course ID"]
            campus = dict["College"]
            if not prof == "" and campus == "H":
                if prof in profs:
                    if not course in profs[prof]:
                        profs[prof].append(course)
                else:
                    profs[prof] = [course]
        return profs

    def get_class_times(list_of_dicts):
        times = []
        for dict in list_of_dicts:
            start = ""
            end = ""
            try:
                start = re.search(r'\d?\d:\d\d\s+(AM|PM)',
                                  dict["Srt1 AM/PM"]).group(0)
                end = re.search(r'\d?\d:\d\d\s+(AM|PM)',
                                dict["End 1 AMPM"]).group(0)
            except:
                continue
            # start = dict["Srt1 AM/PM"]
            # end = dict["End 1 AMPM"]
            days = dict["Days 1"]
            class_time = (start, end, days)
            campus = dict["College"]
            if not class_time in times and campus == "H" and not start == "" \
                    and not end == "" and not days == "":
                times.append(class_time)
        return times

    # One possibility for how to find out which labs go with which courses.
    # Currently catches some "labs" that aren't actually labs for those courses.
    # Course '333' seems especially to be a strange corner case.
    # The issue may also be that this doesn't take sections into account in matching.
    # def get_lab_courses(list_of_dicts):
    #  lab_courses = {}
    #  student_courses = get_student_prefs_enrolled(list_of_dicts)
    #  courses = get_courses(list_of_dicts)
    #  for dict in list_of_dicts:
    #    course = dict["Course ID"]
    #    dept = dict["Subject"]
    #    level = dict["Level"]
    #    student = dict["Student"]
    #    units = dict["Unit Taken"]
    #    campus = dict["College"]
    #    if units == "0" and campus == "H":  # we think this is a lab class
    #      all_courses = student_courses[student]
    #      for enrolled_course in all_courses:
    #        if not enrolled_course == course and enrolled_course in courses:
    #          course_dict = courses[enrolled_course]
    #          enrolled_dept = course_dict["Subject"]
    #          enrolled_level = course_dict["Level"]
    #          enrolled_units = course_dict["Unit Taken"]
    #          enrolled_campus = course_dict["College"]
    #          if enrolled_units > 0 and enrolled_dept == dept and enrolled_level == level \
    #              and enrolled_campus == campus:
    #            print enrolled_course + " " + course
    #            if enrolled_course in lab_courses:
    #              if not course in lab_courses[enrolled_course]:
    #                lab_courses[enrolled_course].append(course)
    #            else:
    #              lab_courses[enrolled_course] = [course]
    #  return lab_courses

    def write_prefs_to_file(list_of_dicts, filename):
        student_prefs = Hav.get_student_prefs_enrolled(list_of_dicts)
        f = open(filename, 'w')
        f.write("Students\t" + str(len(student_prefs)) + "\n")
        for student in student_prefs:
            towrite = student + "\t"
            for course in student_prefs[student]:
                towrite = towrite + course + " "
            towrite = towrite + "\n"
            f.write(towrite)

    def write_class_times_to_file(list_of_dicts, f):
        class_times = Hav.get_class_times(list_of_dicts)
        f.write("Class Times\t" + str(len(class_times)) + "\n")
        i = 1
        for (start, end, days) in class_times:
            f.write(str(i) + "\t" + start + " " + end + " " + days + "\n")
            i = i + 1

    def write_rooms_to_file(list_of_dicts, f):
        room_capacities = Hav.get_room_sizes(list_of_dicts)
        f.write("Rooms\t" + str(len(room_capacities)) + "\n")
        for room in room_capacities:
            f.write(room + "\t" + str(room_capacities[room]) + "\n")

    def write_num_classes_to_file(list_of_dicts, f):
        num_classes = len(Hav.get_courses(list_of_dicts))
        f.write("Classes\t" + str(num_classes) + "\n")

    def write_teachers_to_file(list_of_dicts, f):
        prof_courses = Hav.get_prof_courses(list_of_dicts)
        num_profs = len(prof_courses)
        courses = Hav.get_courses(list_of_dicts)
        f.write("Teachers\t" + str(num_profs) + "\n")
        for course in courses:
            f.write(course + "\t")
            f.write(courses[course])
            f.write("\n")

    def write_constraints_to_file(list_of_dicts, filename):
        f = open(filename, 'w')
        Hav.write_class_times_to_file(list_of_dicts, f)
        Hav.write_rooms_to_file(list_of_dicts, f)
        Hav.write_num_classes_to_file(list_of_dicts, f)
        Hav.write_teachers_to_file(list_of_dicts, f)
        f.close()

    # if len(sys.argv) != 4:
    #   print( "Usage: " + sys.argv[0] + " <enrollment.csv> <student_prefs.txt> <constraints.txt>")
    #   exit(1)
    # list_of_dicts = get_data_list_of_dicts(sys.argv[1])
    # write_prefs_to_file(list_of_dicts, sys.argv[2])
    # write_constraints_to_file(list_of_dicts, sys.argv[3])


# get bryn mawr college data
class BMC:
    def get_data_list_of_dicts(filename):
        list = []
        with open(filename) as f:
            f_csv = csv.DictReader(f)
            for row in f_csv:
                list.append(row)
        return list

    def get_room_sizes(list_of_dicts):
        room_sizes_dict = {}
        for dict in list_of_dicts:
            room = dict["Facil ID 1"]
            status = dict["Status"]
            course = dict["Course ID"]
            campus = dict["Catalog"][0]
            if status == "E" and campus == "B" and not room == "":
                if room in room_sizes_dict:
                    if course in room_sizes_dict[room]:
                        room_sizes_dict[room][course] = room_sizes_dict[room][course] + 1
                    else:
                        room_sizes_dict[room][course] = 1
                else:
                    room_sizes_dict[room] = {}
                    room_sizes_dict[room][course] = 1

        room_capacities = {}
        for room in room_sizes_dict:
            capacity = 0
            for course in room_sizes_dict[room]:
                if room_sizes_dict[room][course] > capacity:
                    capacity = room_sizes_dict[room][course]
            room_capacities[room] = capacity
        return room_capacities

    def get_student_prefs_enrolled(list_of_dicts):
        student_prefs = {}
        for dict in list_of_dicts:
            student = dict["Student ID"]
            course = dict["Course ID"]
            status = dict["Status"]
            room = dict["Facil ID 1"]
            if status == "E" and room != "":
                if student in student_prefs:
                    student_prefs[student].append(course)
                else:
                    student_prefs[student] = [course]
        return student_prefs

    def get_courses(list_of_dicts):
        courses = {}
        for dict in list_of_dicts:
            course = dict["Course ID"]
            prof = dict["Instructor ID"]
            campus = dict["Catalog"][0]
            room = dict["Facil ID 1"]
            if not course in courses and campus == "B" and room != "" and prof != '#Value!':
                courses[course] = dict["Instructor ID"]
        return courses

    def get_building(list_of_dicts):
        building = {}
        for dict in list_of_dicts:
            subject = dict["Subject"]
            room = dict["Facil ID 1"]
            if room == None or room == "":
                continue
            if subject in building:
                building[subject].append(room)
            else:
                building[subject] = [room]
        return building

    # Issue: didn't handle the case where a course number is corresponded to multiple courses.
    def get_subject_level(list_of_dicts):
        subject_level = {}
        for dict in list_of_dicts:
            course = dict["Course ID"]
            department = dict["Subject"]
            campus = dict["Catalog"][0]
            level = dict["Catalog"][1]
            if not course in subject_level and campus == "B":
                subject_level[course] = (department, level)
        return subject_level

    def get_prof_courses(list_of_dicts):
        profs = {}
        for dict in list_of_dicts:
            prof = dict["Instructor ID"]
            course = dict["Course ID"]
            campus = dict["Catalog"][0]
            if not prof == "" and campus == "B" and prof != "#Value!":
                if prof in profs:
                    if not course in profs[prof]:
                        profs[prof].append(course)
                else:
                    profs[prof] = [course]
        return profs

    def get_class_times(list_of_dicts):
        times = []
        for dict in list_of_dicts:
            start = ""
            end = ""
            try:
                start = re.search(r'\d?\d:\d\d\s+(AM|PM)',
                                  dict["Srt1 AM/PM"]).group(0)
                end = re.search(r'\d?\d:\d\d\s+(AM|PM)',
                                dict["End 1 AMPM"]).group(0)
            except:
                continue
            days = dict["Days 1"]
            class_time = (start, end, days)
            campus = dict["Catalog"][0]
            if not class_time in times and campus == "B" and not start == "" \
                    and not end == "" and not days == "":
                times.append(class_time)
        return times

    # One possibility for how to find out which labs go with which courses.
    # Currently catches some "labs" that aren't actually labs for those courses.
    # Course '333' seems especially to be a strange corner case.
    # The issue may also be that this doesn't take sections into account in matching.
    # def get_lab_courses(list_of_dicts):
    #  lab_courses = {}
    #  student_courses = get_student_prefs_enrolled(list_of_dicts)
    #  courses = get_courses(list_of_dicts)
    #  for dict in list_of_dicts:
    #    course = dict["Course ID"]
    #    dept = dict["Subject"]
    #    level = dict["Level"]
    #    student = dict["Student"]
    #    units = dict["Unit Taken"]
    #    campus = dict["College"]
    #    if units == "0" and campus == "H":  # we think this is a lab class
    #      all_courses = student_courses[student]
    #      for enrolled_course in all_courses:
    #        if not enrolled_course == course and enrolled_course in courses:
    #          course_dict = courses[enrolled_course]
    #          enrolled_dept = course_dict["Subject"]
    #          enrolled_level = course_dict["Level"]
    #          enrolled_units = course_dict["Unit Taken"]
    #          enrolled_campus = course_dict["College"]
    #          if enrolled_units > 0 and enrolled_dept == dept and enrolled_level == level \
    #              and enrolled_campus == campus:
    #            print enrolled_course + " " + course
    #            if enrolled_course in lab_courses:
    #              if not course in lab_courses[enrolled_course]:
    #                lab_courses[enrolled_course].append(course)
    #            else:
    #              lab_courses[enrolled_course] = [course]
    #  return lab_courses

    def write_building_to_file(list_of_dicts, filename):
        building = BMC.get_building(list_of_dicts)
        f = open(filename, 'w')
        f.write("Building\t" + str(len(building)) + "\n")
        for subject in building:
            towrite = subject + "\t"
            for room in building[subject]:
                towrite = towrite + room + " "
            towrite = towrite + "\n"
            f.write(towrite)

    def write_prefs_to_file(list_of_dicts, filename):
        student_prefs = BMC.get_student_prefs_enrolled(list_of_dicts)
        f = open(filename, 'w')
        f.write("Students\t" + str(len(student_prefs)) + "\n")
        for student in student_prefs:
            towrite = student + "\t"
            for course in student_prefs[student]:
                towrite = towrite + course + " "
            towrite = towrite + "\n"
            f.write(towrite)

    def write_class_times_to_file(list_of_dicts, f):
        class_times = BMC.get_class_times(list_of_dicts)
        f.write("Class Times\t" + str(len(class_times)) + "\n")
        i = 1
        for (start, end, days) in class_times:
            f.write(str(i) + "\t" + start + " " + end + " " + days + "\n")
            i = i + 1

    def write_rooms_to_file(list_of_dicts, f):
        room_capacities = BMC.get_room_sizes(list_of_dicts)
        f.write("Rooms\t" + str(len(room_capacities)) + "\n")
        for room in room_capacities:
            f.write(room + "\t" + str(room_capacities[room]) + "\n")

    def write_num_classes_to_file(list_of_dicts, f):
        num_classes = len(BMC.get_courses(list_of_dicts))
        f.write("Classes\t" + str(num_classes) + "\n")

    def write_teachers_to_file(list_of_dicts, f):
        prof_courses = BMC.get_prof_courses(list_of_dicts)
        num_profs = len(prof_courses)
        courses = BMC.get_courses(list_of_dicts)
        subject_level = BMC.get_subject_level(list_of_dicts)
        building = BMC.get_building(list_of_dicts)
        f.write("Teachers\t" + str(num_profs) + "\n")
        for course in courses:
            f.write(course + "\t")
            f.write(courses[course] + "\t")
            f.write(subject_level[course][0] + "\t")
            for b in building[subject_level[course][0]]:
                f.write(b + "\t")
            f.write("\n")

    def write_constraints_to_file(list_of_dicts, filename):
        f = open(filename, 'w')
        BMC.write_class_times_to_file(list_of_dicts, f)
        BMC.write_rooms_to_file(list_of_dicts, f)
        BMC.write_num_classes_to_file(list_of_dicts, f)
        BMC.write_teachers_to_file(list_of_dicts, f)
        f.close()

    # if len(sys.argv) != 4:
    #   print ("Usage: " + sys.argv[0] + " <enrollment.csv> <student_prefs.txt> <constraints.txt>")
    #   exit(1)
    # list_of_dicts = get_data_list_of_dicts(sys.argv[1])
    # write_prefs_to_file(list_of_dicts, sys.argv[2])
    # write_constraints_to_file(list_of_dicts, sys.argv[3])

# Class Scheduling


# static counter class for experimental timekeeping
class Counter:
    i = 0

    @staticmethod
    def reset():
        Counter.i = 0
        pass

    @staticmethod
    def tick(n=1):
        Counter.i += n
        pass

    @staticmethod
    def set(i):
        Counter.i = i


# Section class for holding data for each timeslot and class
class Section:
    time = None
    room = None
    cls = None  # Class
    applicants = []
    accepted = []
    professor = None
    room = None

    def __init__(self, time, cls, applicants, room=None):
        # We can and should add professor to this?
        self.time = time
        self.room = room
        self.cls = cls
        self.applicants = applicants

    def __repr__(self) -> str:
        return self.__str__()

    def __str__(self) -> str:
        return "Class: " + self.cls + " Professor: " + self.professor + \
            " Time: " + str(self.time) + " Room: " + self.room\
            + " Accepted: " + str(self.accepted)


# todo: priority queue
# todo: make sure students only enrolled in at most 4 classes
def make_schedule(students, classes, rooms, times, profs):
    # array of sections
    schedule = []

    # total starting sections
    sections = {}
    for cls in classes.keys():
        sections[cls] = {}

        # set applicants for the class
        applicants = []
        for student_id in range(len(students)):
            for cls_pref in students["class_list"][student_id]:
                Counter.tick()  # I hope I didn't break anything
                if cls == cls_pref:  # If the student likes this class
                    applicants.append(students["name"][student_id])

            # Could we replace the last few lines with this?
            # Counter.tick(len(students["class_list"][sudent_id]))
            # if cls in students["class_list"][sudent_id]:
            #   applicants.append(students["name"][sudent_id])

        # set applicants for all times of the section
        for time in times:
            Counter.tick()
            sections[cls][time] = Section(time, cls, applicants[:])

    # get sorted list of rooms for each section
    Counter.tick(len(rooms) * (int)(np.log2(len(rooms))))
    sorted_rooms = rooms.sort_values(by="capacity", ascending=False)
    Counter.tick(len(times))
    rooms = {time: sorted_rooms.copy()
             for time in times}            # I don't understand this
    print(sections)

    # while there are valid classes left
    while (True):
        # todo: naive way of doing this, must fix!!!
        # search for the class with the largest possible size
        max_size = 0
        name = ""
        max_cls = None
        max_time = 0
        for cls in sections.keys():  # Class
            for time in sections[cls].keys():  # Time
                s, n = class_size(sections[cls][time], rooms)
                if max_size < s:
                    Counter.tick()
                    max_size = s
                    name = n
                    max_cls = cls
                    max_time = time
        if max_size == 0:
            break

        # print(max_size, max_cls, max_time)

        # get the room info and remove the room from the current section
        idx = rooms[max_time].index[0]
        room = rooms[max_time]["room"][idx]
        rooms[max_time].drop(idx, inplace=True)
        # print(rooms)
        # get section info and append to final schedule
        sec = sections[max_cls][max_time]
        sec.room = room
        sec.professor = classes[max_cls]
        sec.accepted = sec.applicants[:max_size]
        schedule.append(sec)

        # remove conflicting sections from contention
        # sections.pop(max_cls)
        # for cls in profs[sec.professor]:
        #     Counter.tick()
        #     try:
        #         sections[cls].pop(max_time)  # Love this
        #     except:
        #         #print(max_cls, cls)
        #         pass
        # endwhile
        print(sections.pop())

        for time in sections[max_cls]:
            Counter.tick()
            sections[max_cls][time].applicants = []
        for cls in profs[sec.professor]:
            Counter.tick()
            sections[cls][max_time].applicants = []
        for cls in sections:
            Counter.tick()
            sections[cls][max_time].applicants = []

    return schedule


# function for finding max class size of a section :D
def class_size(section: Section, rooms: dict):
    if len(rooms[section.time]) == 0:
        return (0, "")
    idx = rooms[section.time].index[0]
    size = min(len(section.applicants), rooms[section.time]["capacity"][idx])
    name = rooms[section.time]["room"][idx]
    return (size, name)


# find the accuracy of the schedule
def schedule_rating(schedule):
    total = 0
    accepted = 0
    for sec in schedule:
        total += len(sec.applicants)
        accepted += len(sec.accepted)
    return accepted / total


# make a file out of a list of Sections
def schedule_to_file(schedule, output_file):
    # schedule_df = {"Course": [], "Room": [],
    #                "Teacher": [], "Time": [], "Students": []}

    lines = ["Course\tRoom\tTeacher\tTime\tStudents\n"]
    for sec in schedule:
        students = ""
        for student in sec.accepted:
            students += f"{student} "
        lines.append(
            f"{sec.cls}\t{sec.room}\t{sec.professor}\t{sec.time}\t{students}\n")

    #     schedule_df["Course"].append(sec.cls)
    #     schedule_df["Room"].append(sec.room)
    #     schedule_df["Teacher"].append(sec.professor)
    #     schedule_df["Time"].append(sec.time)
    #     schedule_df["Students"].append(sec.accepted)
    # schedule_df = pd.DataFrame.from_dict(schedule_df)

    with open(output_file, "w") as file:
        file.writelines(lines)


# read format data from list of constraints and prefs
def prep_data(constraints, student_prefs):
    row = []
    with open(constraints, "r") as file:
        row = file.readlines()

    i = 0
    rows = int(row[i][-2]) + 1
    times = [str(i) for i in range(int(row[i][-2]))]
    i += 1
    while row[i].split()[0] != "Rooms":
        idx = re.search(r"[0-9]+[\s\t]+", row[0])
        times[i] = row[i][idx.end(0):]
        i += 1

    rooms = {"room": [], "capacity": []}

    i += 1
    while row[i].split()[0] != "Classes":
        r = row[i].split()
        rooms["room"].append(r[0])
        rooms["capacity"].append(int(r[1]))
        i += 1
    rooms = pd.DataFrame.from_dict(rooms)

    profs = {}
    classes = {}
    rows = int(row[i].split()[1]) + 2
    i += 2
    while i < rows:
        r = row[i].split()
        if profs.get(r[1]) != None:
            profs[r[1]] += [r[0]]
        else:
            profs[r[1]] = [r[0]]
        classes[r[0]] = r[1]
        i += 1

    rows = []
    with open(student_prefs, "r") as file:
        rows = file.readlines()

    students = {"name": [], "class_list": []}
    for row in rows[1:]:
        r = row.split()
        students["name"].append(r[0])
        students["class_list"].append(r[1:])

    students = pd.DataFrame.from_dict(students)

    return (students, classes, rooms, times, profs)


# deprecated
# preprocess haverford data
def prep_hav_data(enrollment_data):
    dicts = Hav.get_data_list_of_dicts(enrollment_data)

    class_times = Hav.get_class_times(dicts)

    # convert to dataframe
    rooms = Hav.get_room_sizes(dicts)
    rooms_df = {"room": [], "capacity": []}
    for key in rooms.keys():
        rooms_df["room"].append(key)
        rooms_df["capacity"].append(rooms[key])
    rooms_df = pd.DataFrame.from_dict(rooms_df)

    # convert to dataframe
    student_prefs = Hav.get_student_prefs_enrolled(dicts)
    student_prefs_df = {"name": [], "class_list": []}
    for key in student_prefs.keys():
        student_prefs_df["name"].append(key)
        student_prefs_df["class_list"].append(student_prefs[key])
    student_prefs_df = pd.DataFrame.from_dict(student_prefs_df)

    profs = Hav.get_prof_courses(dicts)
    classes = Hav.get_courses(dicts)

    return (student_prefs_df, classes, rooms_df, class_times, profs)


# deprecated
# preprocess bryn mawr data
def prep_bmc_data(enrollment_data):
    dicts = BMC.get_data_list_of_dicts(enrollment_data)

    class_times = BMC.get_class_times(dicts)

    # convert to dataframe
    rooms = BMC.get_room_sizes(dicts)
    rooms_df = {"room": [], "capacity": []}
    for key in rooms.keys():
        rooms_df["room"].append(key)
        rooms_df["capacity"].append(rooms[key])
    rooms_df = pd.DataFrame.from_dict(rooms_df)

    # convert to dataframe
    student_prefs = BMC.get_student_prefs_enrolled(dicts)
    student_prefs_df = {"name": [], "class_list": []}
    for key in student_prefs.keys():
        student_prefs_df["name"].append(key)
        student_prefs_df["class_list"].append(student_prefs[key])
    student_prefs_df = pd.DataFrame.from_dict(student_prefs_df)

    profs = BMC.get_prof_courses(dicts)
    classes = BMC.get_courses(dicts)

    return (student_prefs_df, classes, rooms_df, class_times, profs)


# make haverford schedule
def make_hav_schedule(data_file, output_dir=""):
    data = prep_hav_data(data_file)
    sch = make_schedule(data[0], data[1], data[2], data[3], data[4])

    if (output_dir != ""):
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        Hav.write_constraints_to_file(
            Hav.get_data_list_of_dicts(data_file), output_dir + "/constraints.txt")
        Hav.write_prefs_to_file(
            Hav.get_data_list_of_dicts(data_file), output_dir + "/student_prefs.txt")

        schedule_to_file(sch, output_dir + "/schedule.txt")

    return sch


# make bryn mawr schedule
def make_bmc_schedule(data_file, output_dir=""):
    data = prep_bmc_data(data_file)
    sch = make_schedule(data[0], data[1], data[2], data[3], data[4])

    if (output_dir != ""):
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

        BMC.write_constraints_to_file(
            BMC.get_data_list_of_dicts(data_file), output_dir + "/constraints.txt")
        BMC.write_prefs_to_file(
            BMC.get_data_list_of_dicts(data_file), output_dir + "/student_prefs.txt")
        schedule_to_file(sch, output_dir + "/schedule.txt")

    return sch
